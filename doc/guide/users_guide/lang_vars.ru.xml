<?xml version="1.0"?>
<!DOCTYPE manualpage SYSTEM "../style/dtd/manual.dtd">

<?xml-stylesheet type="text/xsl" href="../style/xsl/manual.ru.xsl"?>

<manualpage metafile="lang_vars.xml.meta" lang="ru">

<title>Переменные и выражения</title>

<summary>
   В этом разделе Вы найдете информацию о том, как объявлять переменные,
   получать и изменять их значения, а также о выражениях и об использовании
   переменных в выражениях.
</summary>

<section id="vars">
   <title>Переменные</title>
   <p>Как и в любом другом языке программирования, в языке dbPager
      имеется возможность определять переменные с именем и
      соответствующим ему значением и в будущем обращаться к
      переменной по имени, получая ее значение, а также изменять
      значение переменной.</p>
   <subtitle>Определение переменных</subtitle>
   <p>Для определения переменной используется тег
      <term>&lt;dbp:var></term>, с обязательным параметром - именем
      переменной и двумя необязательными параметрами - начальным
      значением переменной и типом переменной, определяющим ее область
      видимости:</p>
   <code highlight="off">&lt;dbp:var <param>name="<value>имя[,имя...]</value>"</param> [<param>value="<value>значение</value>"</param>] [<param>type="<value>тип</value>"</param>]></code>
   <p>В качестве имени переменной (параметр <name>name</name>) может выступать
      любая строка из латинских букв и цифр, но имя переменной не может
      начинаться с цифры. Имя переменной регистронезависимо,
      т.е. "Variable" и "VaRiaBle" обозначают одну и ту же переменную.
      При необходимости определить несколько
      переменных одним оператором (и при необходимости инициализировать
      их одним и тем же значением) можно указать несколько имен переменных,
      разделяя их запятой.</p>
   <p>Начальное значение переменной (параметр <name>value</name>) -
      необязательный параметр; по умолчанию переменная инициализируется пустой
      строкой, но при необходимости, можно задать любое другое начальное значение.</p>
   <p>Тип переменной (параметр <name>type</name>) - необязательный параметр,
      определяющий область видимости переменной. По умолчанию переменная является
      <link to="lang_vars" bookmark="var_types">локальной</link>.</p>
   <p>При успешном определении и инициализации переменной заданным значением,
      происходит последовательное выполнение вложенных тегов. В случае
      возникновения ошибки определения или инициализации переменной генерируется
      <link to="lang_exceptions">программное исключение</link>.</p>
   <subtitle id="var_types">Типы переменных</subtitle>
   <p>Тип переменной определяет ее область видимости, т.е. место сценария,
      где заданная переменная определена, а также время жизни переменной.
      Тип переменной задается при ее определении как параметр <name>type</name>
      тега <name>&lt;dbp:var></name>. Тип переменной может принимать одно из
      следующих значений:</p>
   <table style="single">
      <header>
         <cell>Тип</cell>
         <cell>Описание</cell>
      </header>
      <row>
         <cell>local</cell>
         <cell>Локальная переменная (по умолчанию); область видимости
            переменной ограничена дочерними узлами тега
            <name>&lt;dbp:var></name>.</cell>
      </row>
      <row>
         <cell>user</cell>
         <cell>Переменная пользователя; переменная определена как во всех
            дочерних, так и во всех следующих узлах тега
            <name>&lt;dbp:var></name>. Более того, значение переменной
            доступно и при повторном вызове сценария, а также в других
            сценариях dbPager, вызываемых тем же пользователем, чем
            обеспечивается рабочий сеанс пользователя до тех пор, пока
            пользователь не прервет свой сеанс*.</cell>
      </row>
      <row>
         <cell>global</cell>
         <cell>Глобальная переменная; область видимости переменной
            идентично глобальным переменным. В отличие от глобальных
            переменных, они определены постоянно, даже если пользователь
            прерывал свой рабочий сеанс**.</cell>
      </row>
   </table>
	<p>* Переменные пользователя не передаются на компьютер пользователя,
	    а хранятся в течение ограниченного периода времени на сервере,
	    поэтому вполне безопасно хранить в них конфиденциальную информацию,
	    такую как пароль пользователя и даже признак успешной авторизации.</p>
	<p>** Глобальные переменные с помощью механизма cookies сохраняются на
	    компьютере пользователя, поэтому время их существования не ограничено.
	    Хранить конфиденциальную информацию в таких переменных с точки зрения
	    безопасности нецелесообразно.</p>
   <note>
      <p>Функционирование глобальных переменных и переменных пользователя
         основано на поддержке <term>cookies</term> программным обеспечением
         пользователя.
         В случае отсутствия поддержки cookies (например, в web-браузере
         пользователя такая возможность отключена) глобальные переменные
         не могут быть инициализированы при повторном вызове сценария.</p>
   </note>
   <subtitle id="var_redecl">Переопределение переменных</subtitle>
   <p>При повторном определении с помощью тега <name>&lt;dbp:var></name>
      переменной с именем, уже определенном в текущем уровне вложения,
      происходит переопределение переменной. При этом во всех вложенных в
      <name>&lt;dbp:var></name> тегах становится доступна переопределенная
      переменная, а при выходе из тега <name>&lt;dbp:var></name> - становится
      доступна ранее определенная переменная:</p>
   <code>&lt;!-- объявляем переменную "a" -->
&lt;dbp:var name="a" value="test">
   &lt;!-- значение переменной "а" равно "test" -->
   &lt;p>a={$a}&lt;/p>
   &lt;!-- переопределяем переменную "a" -->
   &lt;dbp:var name="a" value="new">
      &lt;!-- значение переменной "а" равно "new" -->
      &lt;p>a={$a}&lt;/p>
   &lt;/dbp:var>
   &lt;!-- значение переменной "а" вновь равно "test" -->
   &lt;p>a={$a}&lt;/p>
&lt;/dbp:var></code>
   <subtitle>Операции с переменными</subtitle>
   <p>Для присвоения значения определенной ранее переменной используется тег
      <term>&lt;dbp:set></term>, с обязательным параметром - именем
      переменной (<name>name</name>):</p>
   <code highlight="off">&lt;dbp:set <param>name="<value>имя</value>"</param>&gt;значение&lt;/set&gt;</code>
   <p>При изменении значения переменной сначала производится поиск заданной
      переменной в текущем уровне вложения; если переменная с таким именем
      определена, происходит изменение её значения, если не определена,
      происходит поиск переменной с таким именем в предыдущем уровне
      вложения и так далее, до тех пор, пока переменная не будет найдена.
      Если переменная для изменения не определена на всех уровнях иерархии
      сценария, возбуждается программное исключение.</p>
   <p>Получить значение переменной можно с помощью простого выражения
      <term>{$имя переменной}</term>; кроме того, можно использовать значения
      переменных в <link to="lang_vars" bookmark="expressions">более сложных
      выражениях</link>.</p>
   <p>При выполнении тега dbp:set выполняются все вложенные в него теги;
      содержимое выходного потока выполнения этих тегов используется в
      качестве значения присваиваемой переменной. Таким образом, результат
      выполнения подпрограммы можно присвоить заданной переменной
      вместо вывода в выходной поток программы.</p>
   <example>
      <title>Переменные</title>
      <comment>
         <p>Этот пример демонстрирует определение переменной, её переопределение
            и изменение её значения.</p>
      </comment>
      <input>
&lt;dbp:var name="a,b" value="test">
   &lt;p>a={$a}; b={$b}&lt;/p>
   &lt;dbp:set name="b">changed&lt;/dbp:set>
   &lt;p>a={$a}; b={$b}&lt;/p>
   &lt;dbp:var name="a" value="redeclared">
      &lt;p>a={$a}; b={$b}&lt;/p>
   &lt;/dbp:var>
   &lt;p>a={$a}; b={$b}&lt;/p>
&lt;/dbp:var>
      </input>
      <output>
&lt;p>a=test; b=test&lt;/p>
&lt;p>a=test; b=changed&lt;/p>
&lt;p>a=redeclared; b=changed&lt;/p>
&lt;p>a=test; b=changed&lt;/p>
      </output>
   </example>
</section>

<section id="consts">
   <title>Предопределенные переменные</title>
   <p>Перед выполнением сценария dbPager Server инициализирует
      ряд переменных, доступных в любом месте кода сценария. В первую очередь,
      это <link to="lang_overview" bookmark="arguments">аргументы сценария
      приложения</link>, полученные из запроса пользователя; каждый
      аргумент преобразуется в переменную с именем, совпадающим с именем
      аргумента и соответствующим значением.</p>
   <p>Например, если пользователь с помощью Web-браузера вызывал сценарий
      dbPager через Web-сервер с помощью следующего URL:
      <code highlight="off">http://www.server.com/script.dbpx?action=search&amp;what=search+string</code>
      то перед выполнением сценария script.dbpx dbPager Server автоматически
      создаст переменные <name>action</name> и <name>what</name>, содержащие
      значения <value>search</value> и <value>search string</value>
      соответственно.</p>
   <p>Кроме переменных, представляющих собой аргументы приложения, доступны
      переменные, автоматически инициализируемые сервером &mdash; это значения
      заголовков HTTP-запроса клиента. Имена этих переменных состоят из префикса
      <name>HTTP_</name> и имени HTTP-заголовка, у которого символ "тире" заменен на
      символ подчёркивания, например: HTTP_CONTENT_TYPE, HTTP_CONTENT_LANGUAGE
      и др.</p>
</section>

<section id="auto">
   <title>Автоматически создаваемые переменные</title>
   <p>Помимо определения переменной с помощью <name>&lt;dbp:var></name>,
      некоторые другие теги dbPager могут автоматически
      определять и устанавливать определенный набор локальных переменных.
      Документация на такие теги, в таком случае, приводит перечень переменных,
      которые могут автоматически создаваться.</p>
   <example>
      <title>Автоматически создаваемые переменные</title>
      <comment>
         <p>Тег <term>&lt;dbp:sql></term> автоматически создает переменные с именами,
            равными именам выбираемых полей базы данных, инициализируя их
            значениями полей в каждой итерации выборки данных.</p>
         <p>Предположим, что БД содержит таблицу <name>users</name>, содержащую
            поля <name>user_name</name> и <name>user_surname</name> и в таблице
            находится 2 записи: ('Ivan', 'Pupkin') и ('Sasha', 'Shulgin').</p>
      </comment>
      <input>
&lt;table>
   &lt;tr>
      &lt;td>Name&lt;/td>
      &lt;td>Surname&lt;/td>
   &lt;/tr>
   &lt;dbp:sql query="select user_name, user_surname from users">
      &lt;tr>
         &lt;td>{$user_name}&lt;/td>
         &lt;td>{$user_surname}&lt;/td>
      &lt;/tr>
   &lt;/dbp:sql>
&lt;/table>
      </input>
      <output>
&lt;table>
   &lt;tr>
      &lt;td>Name&lt;/td>
      &lt;td>Surname&lt;/td>
   &lt;/tr>
   &lt;tr>
      &lt;td>Ivan&lt;/td>
      &lt;td>Pupkin&lt;/td>
   &lt;/tr>
   &lt;tr>
      &lt;td>Sasha&lt;/td>
      &lt;td>Shulgin&lt;/td>
   &lt;/tr>
&lt;/table>
      </output>
   </example>
   <caution>
      <p>Если автоматически создаваемая переменная совпадет по имени с
         переменной, определенной на предыдущем уровне иерархии сценария,
         то, естественно, ее значение будет на этом уровне вложения переопределено,
         что может привести к несколько неожиданным результатам, поскольку
         в теге, создавшим переменные с таким же именем автоматически и
         в его подуровнях будут использоваться значения этих автоматических
         переменных, а не объявленных выше.</p>
   </caution>
</section>

<section id="expressions">
   <title>Выражения</title>
   <p>Выражение - это последовательность
      <link to="lang_vars" bookmark="expressions_operations">операций</link> и
      <link to="lang_vars" bookmark="expressions_operands">операндов</link>
      (аргументов операций), которая задает
      вычисление. Вычисление может выдавать в качестве результата значение или
      вызывать побочные эффекты - <link to="lang_exceptions">программное
      исключение</link>.</p>
   <p>Сценарий dbPager может содержать выражения, заключаемые в коде
      сценария в фигурные скобки:</p>
   <code highlight="off">Переменная a равна {$a}, а переменная b: {$b}.
Сумма переменных a и b равна: {$a+$b}.</code>
   <p>При необходимости использовать в тексте фигурные скобки, не являющиеся
      частью выражения, необходимо их предварять символом наклонной влево
      черты (слэша):</p>
   <code highlight="off">\{Текст, окруженный фигурными скобками\}</code>
   <p>При выполнении кода сценария dbPager происходит вычисление значения
      выражения и вместо кода выражения подставляется это значение, в
      независимости от месторасположения выражения: выражение с одинаковым
      успехом может быть использовано как в тексте, так и в значениях
      параметров тегов dbPager.</p>
   <example>
      <title>Переменные и выражения</title>
      <comment>
         <p>В этом примере показано использование тега
            <term>&lt;dbp:var></term> для определения переменной и ее
            инициализации, использование выражений для инициализации
            переменной, а также использование выражений в тексте сценария.</p>
      </comment>
      <input>
&lt;dbp:var name="a1" value="2">
   &lt;dbp:var name="a2" value="{$a1 * 10}">
      &lt;p>2+2*10={$a1 + $a2}&lt;/p>
   &lt;/dbp:var>
&lt;/dbp:var>
      </input>
      <output>
&lt;p>2+2*10=22&lt;/p>
      </output>
   </example>
   <p>Выражения в сценариях dbPager могут быть вложенными. В таком случае
      сначала вычисляется выражение максимальной глубины, затем его результат
      подставляется в выражение предыдущего уровня вложенности и вычисление
      значения выражения повторяется.</p>
   <p>Это свойство выражений может быть эффективно использовано для вычисления
      значений выражений, не известных на момент исполнения сценария
      (задаваемых пользователем) и при обращении к переменным и функциям,
      имена которых необходимо вычислить до вычисления выражения.</p>
   <example>
      <title>Калькулятор</title>
      <comment>
         <p>В этом примере показано использование вложенных выражений
            для вычисления формул, задаваемых пользователем - реализация
            простейшего, но полнофункционального калькулятора.</p>
         <p>При первом выполнении сценария генерируется HTML-страница,
            содержащая форму для заполнения пользователем. Переменная
            <name>expr</name> при этом пока не определена, поэтому попытка
            получить её значение для отображения в поле ввода и в строке с
            результатом приведёт к получению пустой строки.</p>
         <p>После ввода пользователем выражения, которое необходимо вычислить
            (в данном примере предполагается, что пользователь ввёл выражение
            <value>(2 + 3)*2</value>) и отправки запроса, происходит повторное
            выполнение сценария. При повторном выполнении переменная
            <name>expr</name> уже будет определена и инициализирована
            строкой <value>(2 + 3)*2</value>, так как dbPager Server создаст
            эту переменную автоматически, поскольку она будет передана
            Web-браузером пользователя. В строку ввода попадет значение
            этой переменной (<value>(2 + 3)*2</value>), но вот в поле с
            результатом это выражение вложено в другое, поэтому произойдет
            вычисление содержимого переменной, т.е. результат вычисления
            выражения, заданного пользователем.</p>
      </comment>
      <input>&lt;?xml version="1.0" encoding="UTF-8" ?>

&lt;!DOCTYPE dbp:module SYSTEM "http://dbpager.org.ru/shemas/dbp/3.0/module.dtd">

&lt;dbp:module xmlns:dbp="http://dbpager.org.ru/shemas/dbp/3.0"
 xmlns="http://www.w3.org/1999/xhtml">

   &lt;html>
      &lt;head>&lt;title>Калькулятор&lt;/title>&lt;/head>
      &lt;body>
         &lt;form method="post">
            &lt;p>Выражение:&lt;/p>
            &lt;input type="text" name="expr" value="{$expr}"/>
            &lt;input type="submit"/>
         &lt;/form>
         &lt;p>Результат: {{$expr}}&lt;/p>
      &lt;/body>
   &lt;/html>

&lt;/dbp:module></input>
      <output>
&lt;html>
   &lt;head>&lt;title>Калькулятор&lt;/title>&lt;/head>
   &lt;body>
      &lt;form method="post">
         &lt;p>Выражение:&lt;/p>
         &lt;input type="text" name="expr" value="(2 + 3)*2"/>
         &lt;input type="submit"/>
      &lt;/form>
      &lt;p>Результат: 10&lt;/p>
   &lt;/body>
&lt;/html>
      </output>
   </example>
   <subtitle id="expressions_operations">Операции</subtitle>
   <p>Арифметические операции используются при вычислениях с числами. При
      попытке использовать арифметические операции над строками (переменными,
      не являющимися числами), возбуждается программное исключение.
      Ниже представлен перечень всех арифметических операций,
      поддерживаемых dbPager Server:</p>
   <table style="single">
      <header>
         <cell>Операция</cell>
         <cell>Описание</cell>
      </header>
      <row>
         <cell>+</cell>
         <cell>сложение</cell>
      </row>
      <row>
         <cell>-</cell>
         <cell>вычитание, в случае проведения операции над двумя операндами,
               либо смена знака у числа, в случае проведения операции над одним
               операндом (унарная операция).</cell>
      </row>
      <row>
         <cell>*</cell>
         <cell>умножение</cell>
      </row>
      <row>
         <cell>/</cell>
         <cell>деление</cell>
      </row>
      <row>
         <cell>^</cell>
         <cell>возведение в степень</cell>
      </row>
   </table>
   <p>Логические операции используются для сравнения операндов:</p>
   <table style="single">
      <header>
         <cell>Операция</cell>
         <cell>Описание</cell>
      </header>
      <row>
         <cell>&lt;</cell>
         <cell>Меньше. Результат операции равен единице, если левый операнд
            меньше правого и нулю в противном случае.</cell>
      </row>
      <row>
         <cell>&lt;=</cell>
         <cell>Меньше или равно. Результат операции равен единице, если левый
            операнд меньше либо равен правому и нулю в противном случае.</cell>
      </row>
      <row>
         <cell>></cell>
         <cell>Больше. Результат операции равен единице, если левый операнд
            больше правого и нулю в противном случае.</cell>
      </row>
      <row>
         <cell>>=</cell>
         <cell>Больше или равно. Результат операции равен единице, если левый
            операнд больше либо равен правому и нулю в противном случае.</cell>
      </row>
      <row>
         <cell>=</cell>
         <cell>Равно. Результат операции равен единице, если левый операнд
            равен правому и нулю в противном случае.</cell>
      </row>
      <row>
         <cell>!= или &lt;></cell>
         <cell>Не равно. Результат операции равен единице, если левый операнд
            не равен правому и нулю в противном случае.</cell>
      </row>
      <row>
         <cell>&amp;</cell>
         <cell>"И". Результат операции равен единице, если и левый и правый
            операнды равны единице и нулю в противном случае.</cell>
      </row>
      <row>
         <cell>|</cell>
         <cell>"ИЛИ". Результат операции равен единице, если либо левый, либо
            правый операнды равны единице и нулю в противном случае.</cell>
      </row>
      <row>
         <cell>!</cell>
         <cell>"НЕ" (унарная операция). Результат операции равен единице,
            если правый операнд равен нулю и нулю в противном случае.</cell>
      </row>
   </table>
   <note>
      <p>В связи с особенностями XML-формата, символы "&lt;" и "&amp;" имеют
         специальное значение, поэтому в коде сценария должны использоваться
         их эквиваленты - "&amp;lt;" и "&amp;amp;" соответственно. В противном
         случае файл сценария не сможет быть загружен, так как не будет
         являться конформным XML-документом.</p>
   </note>
   <p>При использовании логических операций, операнды сначала приводятся
      к числам и производится сравнение, а в случае, когда один из операндов
      не может быть приведен к числу - сравнение выполняется над строками.</p>
   <p>Приоритеты выполнения операций - арифметические. В первую очередь
      выполняются операции возведения в степень, умножение и деление,
      после чего выполняются операции сложения и вычитания. Наконец,
      последними исполняются логические операции. При необходимости изменить
      приоритет выполнения операций, используйте скобки.</p>
   <subtitle id="expressions_operands">Операнды</subtitle>
   <p>Операндами в выражении могут быть переменные, числовые и строковые
      константы, встроенные и внешние функции. В нижеследующей таблице приведен
      перечень поддерживаемых dbPager Server операндов:</p>
   <table style="single">
      <header>
         <cell>Операнд</cell>
         <cell>Название</cell>
         <cell>Описание</cell>
      </header>
      <row>
         <cell><name>$имя</name></cell>
         <cell>Переменная</cell>
         <cell>Значением операнда является значение определенной переменной
            с заданным именем. Если переменная не определена, значение
            операнда - пустая строка.</cell>
      </row>
      <row>
         <cell><name>имя</name>(<value>[аргумент1[,аргумент2...]]</value>)</cell>
         <cell>Встроенная функция</cell>
         <cell></cell>
      </row>
      <row>
         <cell><name>@имя</name>(<value>[аргумент1[,аргумент2...]]</value>)</cell>
         <cell>Внешняя функция</cell>
         <cell></cell>
      </row>
      <row>
         <cell><name>"текст"</name></cell>
         <cell>Строковая константа</cell>
         <cell>Строковая константа, ноль или более символов, заключенных в
            одинарные или двойные кавычки.</cell>
      </row>
      <row>
         <cell>число</cell>
         <cell>Числовая константа</cell>
         <cell>Десятичное число, в качестве разделителя дробной и целой части
            используется точка.</cell>
      </row>
   </table>
   <subtitle>Функции</subtitle>
   <p>Для использования в выражениях доступен ряд функций. Функции принимают
      аргументы, перечисляемые в скобках за именем функции и возвращают
      значение. В языке dbPager определены следующие функции:</p>
   <table style="single">
      <header>
         <cell>Функция</cell>
         <cell>Описание</cell>
      </header>
      <row>
         <cell><name>byte</name>(<value>число</value>)</cell>
         <cell>Возвращает символ с указанным кодом символа.
         </cell>
      </row>
      <row>
         <cell><name>concat</name>(<value>строка1[,строка2...]</value>)</cell>
         <cell>Объединяет несколько строк в одну и возвращает её значение.</cell>
      </row>
      <row>
         <cell><name>len</name>(<value>строка</value>)</cell>
         <cell>Возвращает длину строки в символах.</cell>
      </row>
      <row>
         <cell><name>pos</name>(<value>подстрока,строка</value>)</cell>
         <cell>Производит поиск подстроки в строке символов. Возвращает
            номер позиции нахождения первого входа подстроки, если подстрока
            была найдена, или 0, если подстрока не была найдена.</cell>
      </row>
      <row>
         <cell><name>encode_base64</name>(<value>строка</value>)
         </cell>
         <cell>Возвращает строку, закодированную алгоритмом base64.</cell>
      </row>
      <row>
         <cell><name>decode_base64</name>(<value>строка</value>)
         </cell>
         <cell>Возвращает строку, раскодированную из base64-закодированной строки.</cell>
      </row>
      <row>
         <cell><name>md5</name>(<value>строка</value>)</cell>
         <cell>Возвращает хэш строки, полученный по алгоритму MD5.</cell>
      </row>
      <row>
         <cell><name>uuid</name>()</cell>
         <cell>Возвращает строку, содержащую уникальное значение.</cell>
      </row>
      <row>
         <cell><name>encode_url</name>(<value>строка</value>)</cell>
         <cell>Возвращает строку, закодированную алгоритмом кодирования URL,
           определенному в RFC 1738 (пробел кодируется символом "+").</cell>
      </row>
      <row>
         <cell><name>decode_url</name>(<value>строка</value>)</cell>
         <cell>Возвращает строку, разкодированную алгоритмом кодирования URL,
           определенному в RFC 1738 (пробел кодируется символом "+").</cell>
      </row>
   </table>
</section>

</manualpage>
